{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Melange OCaml for JavaScript developers Melange is a fork of the OCaml compiler that compiles to JavaScript. Melange strives to provide the best integration with both the OCaml and JavaScript ecosystems. To know more about it start by reading the introductory tutorial , then check the Learn section for more information. Getting Started Learn Features A Solid Type System Melange leverages OCaml's powerful type system to catch more bugs at compile time. Large, complex codebases become easy to maintain and refactor. First-Class Editor and Tooling Melange can use the same editor integrations as OCaml, which exist for VSCode, Vim, or Emacs. They allow to provide type inspection, autocomplete and more. It also has first-class integration with Dune , OCaml's most used build system. JavaScript Integration Whether you want to use existing JavaScript packages from NPM, or use your own JavaScript libraries in your projects, Melange has you covered. With an expressive bindings language, and an ergonomic compilation model, Melange can help you build robust applications that leverage functionality from the JavaScript ecosystem. Stable and Industry Backed Melange builds on top of decades of type system research, compiler engineering and tooling development to provide a polished developer experience. Companies like Ahrefs use Melange daily to deploy web applications to their users.","title":"Home"},{"location":"#melange","text":"OCaml for JavaScript developers Melange is a fork of the OCaml compiler that compiles to JavaScript. Melange strives to provide the best integration with both the OCaml and JavaScript ecosystems. To know more about it start by reading the introductory tutorial , then check the Learn section for more information. Getting Started Learn","title":"Melange"},{"location":"community/","text":"Community The community tends to congregate in the following forums: OCaml Discourse Web Forum is a friendly, online forum for OCaml discussion. If you prefer to have long-form conversation rather than just chatting, this is the place to do it. Reason Discord , where there is a specific #melange channel OCaml Discord Melange GitHub repository","title":"Community"},{"location":"community/#community","text":"The community tends to congregate in the following forums: OCaml Discourse Web Forum is a friendly, online forum for OCaml discussion. If you prefer to have long-form conversation rather than just chatting, this is the place to do it. Reason Discord , where there is a specific #melange channel OCaml Discord Melange GitHub repository","title":"Community"},{"location":"getting-started/","text":"Getting started Get up and running with Melange in no time! Install opam To work with Melange, you need to install opam , a source-based package manager for OCaml. Instructions for installing opam on different operating systems can be found at the opam install page . Template The easiest way to get started with Melange is by using the melange-opam-template . Follow the instructions in the readme file to configure the local opam switch and download the necessary dependencies to build the project. Editor integration Melange has plugins for many editors, but the most actively maintained are for Visual Studio Code, Emacs, and Vim. For Visual Studio Code, install the OCaml Platform Visual Studio Code extension from the Visual Studio Marketplace. When you load an OCaml source file for the first time, you may be prompted to select the toolchain in use. Select the version of OCaml you are using from the list, such as 4.14.1. Further instructions for configuration can be found in the extension repository . For Emacs and Vim, the configuration may vary depending on the case, and there are several options available. You can read about them in the editor setup page of the OCamlverse documentation site. Alternative package managers (experimental) Although the recommended setup for Melange projects is with opam, Melange can also be used with other package managers, such as esy and Nix . There is also a Melange project template for esy available, similar in spirit to the Melange opam template mentioned above.","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Get up and running with Melange in no time!","title":"Getting started"},{"location":"getting-started/#install-opam","text":"To work with Melange, you need to install opam , a source-based package manager for OCaml. Instructions for installing opam on different operating systems can be found at the opam install page .","title":"Install opam"},{"location":"getting-started/#template","text":"The easiest way to get started with Melange is by using the melange-opam-template . Follow the instructions in the readme file to configure the local opam switch and download the necessary dependencies to build the project.","title":"Template"},{"location":"getting-started/#editor-integration","text":"Melange has plugins for many editors, but the most actively maintained are for Visual Studio Code, Emacs, and Vim. For Visual Studio Code, install the OCaml Platform Visual Studio Code extension from the Visual Studio Marketplace. When you load an OCaml source file for the first time, you may be prompted to select the toolchain in use. Select the version of OCaml you are using from the list, such as 4.14.1. Further instructions for configuration can be found in the extension repository . For Emacs and Vim, the configuration may vary depending on the case, and there are several options available. You can read about them in the editor setup page of the OCamlverse documentation site.","title":"Editor integration"},{"location":"getting-started/#alternative-package-managers-experimental","text":"Although the recommended setup for Melange projects is with opam, Melange can also be used with other package managers, such as esy and Nix . There is also a Melange project template for esy available, similar in spirit to the Melange opam template mentioned above.","title":"Alternative package managers (experimental)"},{"location":"learn/","text":"Learn New to OCaml? As Melange is a fork of the OCaml compiler, this documentation is designed to include the differences between both. But for the parts that overlap between Melange and OCaml, we will always refer to the main OCaml documentation throughout these docs. If you are completely new to OCaml, you might want to get familiar first with the language, there are plenty of resources available , but we recommend the following tutorials from the official OCaml website: A First Hour With OCaml OCaml Exercises Why Melange Melange is a fork of the OCaml compiler that produces JavaScript. OCaml offers an industrial-strength, state-of-the-art type system and provides type inference with very few type annotations, proving invaluable in managing large projects. JavaScript is one of the most pervasive platforms to deploy and run software. Thanks to years of efforts to improve the different VMs available, the JavaScript code running on browsers and other environments is heavily optimized and can support use cases for large products and tools. Melange helps developers and companies bring the advantages of the OCaml platform to users of the Web platform in a way that makes it easy for developers to integrate with both ecosystems. A bit of history To better understand where Melange comes from, it might help to go through some of the related projects that have appeared over the last decade or so. Js_of_ocaml Js_of_ocaml is another OCaml to JavaScript compiler that was made public in 2011. In the presentation paper published in 2013, it\u2019s explicitly mentioned that one of its design goals was to remain as compatible as possible with the OCaml compiler, without requiring a lot of maintenance work, as the OCaml community was not excessively large at the time. To achieve this goal, Js_of_ocaml picks the bytecode generated by OCaml batch compilation and generates JavaScript from it. OCaml bytecode has a very stable interface, so Js_of_ocaml can easily upgrade to new versions of the compiler. Due to this design decision, it can also remain compatible with most of the OCaml ecosystem, as long as the tools or libraries don\u2019t rely on C code. The downside of using bytecode is that it gets harder to communicate with existing JavaScript code. For example, a Js_of_ocaml string is not compiled as a JavaScript string, so some conversion is needed for this and other types. Another downside is that the resulting JavaScript is hard to read, as it is converted from a low-level representation like bytecode. BuckleScript Then, in 2016, Bob Zhang suggests on a Js_of_ocaml repository issue the possibility to start converting to JavaScript from an earlier stage of the compilation process, instead of using bytecode. This proposal fundamentally diverges from Js_of_ocaml original design and goals, so he starts working on what will become BuckleScript. BuckleScript gets some inspiration from Js_of_ocaml, for example in the way that JavaScript objects are represented with Js.t . But it differs from Js_of_ocaml in many ways: it can generate more readable and lighter code. It also generates one .js file per module, which makes it easier to integrate with existing JavaScript codebases. BuckleScript puts a big emphasis on communicating with JavaScript code through a rich collection of attributes applied to external primitives. Reason Around the same year, a project called Reason appears at Facebook. Led by Jordan Walke, the idea is to create an alternate syntax for OCaml that is closer to C and JavaScript. Even if Reason has no take on which platform the code is deployed \u2014native applications binaries, or web applications using JavaScript as a target language\u2014, BuckleScript adds first class support for Reason from early on. At that point, it becomes evident that the combination of Reason with BuckleScript is a great match: BuckleScript provides tools and infrastructure to work with JavaScript ecosystem, while Reason allows developers to write their programs in a syntax they are familiar with. Over time, and with help of other Facebook employees and the community providing bindings to pervasive JavaScript libraries like React.js with reason-react , the combination of Reason and BuckleScript gains adoption. BuckleScript gets rebranded However, at some point the goals of both BuckleScript and Reason projects become harder to reconcile. In August 2020, the BuckleScript team decides to rename to ReScript, stops adding support for the latest versions of the Reason parser, and replaces it with a new parser that changes the syntax. The reasons for the rebranding are explained in the official ReScript blog post . The rebranding is trying to ease onboarding and adoption of the ReScript language, giving the project more chances to compete with mainstream compiled-to-JavaScript languages like TypeScript. However, for many existing users of BuckleScript and Reason, it is the explicit confirmation of something that had been hinted implicitly before: ReScript goals are not compatible with providing a good integration with the OCaml ecosystem. Melange: back to OCaml This is where Melange comes in. A few weeks after the rebranding of BuckleScript to ReScript, Ant\u00f3nio Monteiro starts working on a fork of BuckleScript with a simple (not easy) goal: replace the Ninja build system , which BuckleScript had been using from its creation, with Dune , which is the most used build system for OCaml projects. This fork of BuckleScript is later named Melange. After finishing the switch from Ninja to Dune, several additional features are added to bring it closer to OCaml. Some examples are the upgrade of the OCaml compiler version used by Melange, or modelling the changes to the OCaml compiler that Melange uses as just a plain library, instead of a full fork of the whole compiler. In September 2022, Ahrefs decides to invest on Melange by funding a project to deepen the integration between Dune and Melange. This project achieves its completion in Spring 2023, with the migration of Ahrefs frontend codebase to Melange and the new public releases that support it: version 3.8 of Dune and 1.0 of Melange. Package management Melange uses a dual approach to package management: For Melange libraries and bindings, use opam . For JavaScript packages required by Melange bindings, use npm (or any of its alternatives ). This dual approach has some obvious downsides, such as forcing Melange applications to have both an <app_name>.opam and a package.json file. However, it unlocks the advantages of both ecosystems. As we will see below, opam has been designed for the OCaml language, which makes the developer experience fundamentally different from npm in the way it handles and installs dependencies. In the following sections, we will go through the details of how to use opam to define the dependencies of our application, as well as how to publish packages in the public opam repository. However, this documentation is not exhaustive and only covers what we believe are the most important parts for Melange developers. If you want to learn more about opam, please refer to the opam manual and FAQ page . opam for Melange developers Before diving into specifics about using opam, there are the two relevant differences between opam and npm that are worth mentioning. 1. One version of each package At any given time, any opam switch can only at most a single version of a package. This is known as a flat dependency graph, and some package managers in other languages (like Bower ) follow a similar approach. A flat dependency graph means that, for example, it is impossible to have two versions of reason-react installed in the same project. This avoids some headaches when one inadvertently installs two versions of a dependency. Also, and specifically for Melange, it helps keep the resulting JavaScript bundle lean and reduce page load for browser-based applications. On the other hand, upgrading your project dependencies to more recent versions might become tricky. Due to the restriction where only one version of a package can be installed, there is a higher chance for conflicts between the constraints of the transitive dependencies. If opam cannot find a solution, these conflicts need to be solved manually. This generally involves updating the conflicting dependency to make it compatible with a newer version of Melange or a transient dependency. 2. A source-based package manager for a compiled language opam distributes just the source code of the packages and leaves the compilation step to a build phase that runs when consuming them, after they have been fetched. As the package manager for a compiled language like OCaml, opam has first-class support for this build step. Every package must tell opam how it should be built, and the way to do this is by using the build field in the package .opam file. This is different from how npm handles packages. Because npm has been designed for JavaScript (an interpreted language) having a build step makes no sense. Whenever any project or community tries to use npm to distribute software that includes code written in compiled languages, the burden to distribute pre-built binaries is imposed on library authors, like the node-sass example shows. As Melange relies heavily on OCaml packages for the compilation step (either PPXs, linters, instrumentation, or any other build-time package), using opam provides access to these tools without library authors having to care about creating and distributing pre-built versions of their packages. Let\u2019s go now through the most common actions with opam when working on Melange projects. The following guide is based on the amazing opam for npm/yarn users guide by Louis ( @khady ). Initial configuration The first thing to do is to install opam. There is an official documentation page on installation. Most of the time, we can simply get it from your package manager. Otherwise, binaries are provided for every platform. There is a necessary first step before using opam: opam init -a Here is what the documentation of the opam init command says: The init command initialises a local \"opam root\" (by default, ~/.opam/ ) that holds opam\u2019s data and packages. This is a necessary step for normal operation of opam. The initial software repositories are fetched, and an initial 'switch' can also be installed, according to the configuration and options. These can be afterwards configured using opam switch and opam repository. Additionally, this command allows to customise some aspects of opam\u2019s shell integration, when run initially (avoiding the interactive dialog), but also at any later time. The interesting parts are: The opam root is at ~/.opam opam uses shell integration to make our life easier opam uses the concept of a switch A switch is the equivalent of the node_modules folder in npm\u2019s world. It contains all the packages that are installed. There are local switches and global switches, in the same way we can have a node_modules folder local to our project or install global dependencies using yarn global or npm install -g . Global switches can be handy sometimes, but to avoid confusion, the recommendation is to avoid them. The default settings can be changed if the -a option is omitted while calling opam init . Minimal app.opam file The equivalent to package.json is an app.opam file, where app is the name of the package. It is possible to have multiple opam files in the same directory or project. There is no opam command to manipulate the opam file. A command similar to npm init or yarn add does not exist in opam, so the updates in .opam files have to be done by hand. A minimal .opam file looks like this: opam-version: \"2.0\" name: \"my-app\" authors: \"Louis\" homepage: \"https://github.com/khady/example\" maintainer: \"ex@ample.com\" dev-repo: \"git+ssh://git@github.com:khady/example.git\" bug-reports: \"https://github.com/khady/example/issues\" version: \"0.1\" build: [ [ \"dune\" \"subst\" ] {pinned} [ \"dune\" \"build\" \"-p\" name \"-j\" jobs ] ] depends: [ \"dune\" {build} ] build: tells opam that dune is needed only to build the project. Installing packages The first thing we need is a local switch in the current project. To verify if a switch exists already, we can look for a _opam directory at the root of the project or use the opam switch command to identify if a switch already exists in the project folder. If it does not exist, we can create it with: opam switch create . 4.14.1 --deps-only If it exists, we can install the dependencies of the project with: opam install . --deps-only Add new packages To add a new package to the opam switch, we can do: opam install <package_name> But opam will not modify the app.opam file during the installation, this has to be done by hand. It is as simple as adding the name of the package in the depends field. Linking packages for development This can be achieved with opam pin . For example, to pin a package to a specific commit on GitHub: opam pin add reason-react.dev https://github.com/reasonml/reason-react.git#61bfbfaf8c971dec5152bce7e528d30552c70bc5 Branch names can also be used. opam pin add reason-react.dev https://github.com/reasonml/reason-react.git#feature A shortcut to get the latest version of a package is to use the --dev-repo flag, e.g. opam pin add reason-react.dev --dev-repo To remove the pinning for any package, use opam unpin <package_name> or opam pin remove <package_name> . For other options, the command is well described in the official documentation . Upgrading packages To upgrade the installed packages to the latest version, run: opam upgrade <package_name> opam upgrade is also able to upgrade all the packages of the local switch if no package name is given. There is one big difference compared to npm: opam stores a local copy of the opam repository, like apt-get does in Debian. So we often want to update this copy before requesting an upgrade: opam update && opam upgrade <package_name> Dev dependencies You can use the with-dev-setup field to define dependencies that are only required at development time. For example: depends: [ \"ocamlformat\" {with-dev-setup} ] This has to be combined with the --with-dev-setup flag when installing dependencies, e.g. opam install --deps-only --with-dev-setup . Lock files Lock files are also not common yet in the opam world, but they can be used as follows: Using opam lock to generate the lock file when needed (basically after each opam install or opam upgrade ). Adding --locked to all the opam install --deps-only and opam switch create . commands. Bindings and package management When writing Melange libraries that bind to existing JavaScript packages, the users of the Melange library will have to make sure to install those JavaScript packages manually. This is similar to how OCaml bindings to system libraries work, see examples like ocaml-mariadb or ocurl . The advantage of this approach \u2014as opposed to vendoring the JavaScript packages inside the bindings\u2014 is that it gives users of the bindings complete flexibility over the way these JavaScript packages are downloaded and bundled. Build system Melange is deeply integrated with Dune , the most widely used build system for OCaml. This integration enables developers to create a single project with both OCaml native executables and frontend applications that are built with Melange, and even share code between both platforms in an easy manner. The way Dune and Melange work with each other is as follows: Dune orchestrates and plans the work needed to compile a project, copies files when needed, and prepares everything so that Melange takes OCaml source files and convert them into JavaScript code. Let\u2019s now dive into the Melange compilation model and go through a brief guide on how to work with Dune in Melange projects. Compilation model Melange compiles a single source file (either .ml or .re for Reason syntax) to a single JavaScript module. This simplifies debugging the produced JavaScript code and allows to import assets like CSS files and fonts in the same way as one would do in a JavaScript project. Even if Melange does not handle the bundling of JavaScript code for web applications, its compilation model allows integration with tools such as Webpack , or other alternatives . The Melange opam template can be used as reference, as it provides an example of how to integrate Melange with Webpack. Dune for Melange developers Dune is an OCaml build system that Melange projects can use to specify libraries and applications. It\u2019s optimized for monorepos and makes project maintenance easier. This section provides an overview of Dune\u2019s features and explains how to use it to build Melange applications. Features Dune is designed with OCaml in mind, which makes it an ideal tool for Melange developers. It provides several benefits, including: Easy specification of libraries and executables. Optimized for monorepos: no need for npm link or similar solutions. Easy project maintenance, as one can rearrange folders without updating the paths to libraries. Hygiene is maintained in Dune by never writing in source folders by default, unless explicitly configured to do so. All the compilation artifacts are placed in a separate _build folder. Dune provides a variety of additional features including cram tests , integration with Odoc , Melange, Js_of_ocaml , watch mode , Merlin/LSP integration for editor support, cross compilation , and generation of opam files . Creating a new project To understand how to use Dune, let\u2019s create a small Melange application using it. First of all, create an opam switch, like shown in the package management section : opam switch create . 4.14.1 --deps-only Install Dune and Melange in the switch: opam install dune melange Create a file named dune-project . This file will tell Dune a few things about our project configuration: (lang dune 3.8) (using melange 0.1) The first line (lang dune 3.8) tells Dune which version of the \"Dune language\" (the language used in dune files) we want to use. Melange is only compatible with versions of the Dune language equal or greater than 3.8. The second line (using melange 0.1) tells Dune we want to use the Melange extension of the Dune language . Adding a library Next, create a folder lib , and a dune file inside. Put the following content inside the dune file: (library (name lib) (modes melange)) Create a file lib.ml in the same folder: let name = \"Jane\" The top level configuration entries \u2014like the library one that appears in the dune file\u2014 are referred to as stanzas , and the inner ones \u2014like name and modes \u2014 are referred to as fields of the stanza. All stanzas are well covered in the Dune documentation site, where we can find the reference for the library stanza . Dune is designed to minimize changes in configuration when the project folder structure changes, so one can move around the lib folder to another place inside the project, and all build commands will still keep working without any changes in Dune configuration. Very handy! Entry points with melange.emit Libraries are useful to encapsulate behavior and logical components of our application, but they won\u2019t produce any JavaScript artifacts on their own. To generate JavaScript code, we need to define an entry point of our application. In the root folder, create another dune file: (melange.emit (target app) (libraries lib)) And an app.ml file: let () = Js.log Lib.name The melange.emit stanza is the one that tells Dune to generate JavaScript files from a set of libraries and modules. In-depth documentation about this stanza can be found on the Dune docs . The file structure of the app should look something like this: project_name/ \u251c\u2500\u2500 _opam \u251c\u2500\u2500 lib \u2502 \u251c\u2500\u2500 dune \u2502 \u2514\u2500\u2500 lib.ml \u251c\u2500\u2500 dune-project \u251c\u2500\u2500 dune \u2514\u2500\u2500 main.ml Building the project We can build the project now, which will produce the JavaScript code from our sources using the Melange compiler: $ dune build @melange This command tells dune to build all the targets that have an alias melange attached to them. Aliases are build targets that don\u2019t produce any file and have configurable dependencies. By default, all the targets in a melange.emit stanza and the libraries it depends on are attached to the melange alias. We can define explicit aliases though, as we will see below. If everything went well, we should be able to run the resulting JavaScript with Node. As we mentioned while going through its features, Dune places all artifacts inside the _build folder to not pollute any source folders. So we will point Node to the script placed in that folder, to see the expected output: $ node _build/default/app/app.js Jane One thing to note is that we have to look for the app.js file inside an app folder, but we don\u2019t have any such folder in our sources. The reason why this folder is created is to support multiple melange.emit stanzas in the same folder. To support this scenario, Dune will use the target field defined in the melange.emit to place the artifacts generated from a melange.emit stanza in the following folder: _build/default/$path-to-directory-of-melange-emit-stanza/$target This allows to have two or more melange.emit stanzas in the same folder without conflicts or overrides between each other. Using aliases The default melange alias is useful for prototyping or when working on small projects, but larger projects might define multiple entry points or melange.emit stanzas. In these cases, it is useful to have a way to build individual stanzas. To do so, one can define explicit aliases for each one of them by using the alias field. Let\u2019s define a custom alias app for our melange.emit stanza: (melange.emit (target app) (alias app) (libraries lib)) Now, when building with Dune, we can refer to this new alias: $ dune build @app Note that if we try to build again using the default melange alias, Dune will return an error, as there are no more targets attached to it. $ dune build @melange Error: Alias \"melange\" specified on the command line is empty. It is not defined in . or any of its descendants. Handling assets The last topic we will go through in this demo project is asset handling. Sometimes we want to use CSS files, fonts, or other assets in our Melange projects. Due to the way Dune works, our assets will have to be copied to the _build folder as well. To make this process as easy as possible, the Melange integration with Dune provides two ways to do this: For library stanzas, a field melange.runtime_deps For melange.emit stanzas, a field runtime_deps Both fields are documented in the Melange page of the Dune documentation site. For the sake of learning how to work with assets in a Melange project, let\u2019s say that we want to read the string in Lib.name from a text file. We will combine the field melange.runtime_deps with some bindings to Node that Melange provides. Check the next section, \"Communicate with JavaScript\" , it you want to learn more about how bindings work. So, let\u2019s add a new file name.txt inside lib folder, that just contains the name Jane . Then, adapt the lib/dune file. We will need to add the melange.runtime_deps field, as well as a preprocessing field that will allow to use the bs.raw extension, in order to get the value of the __dirname environment variable: (library (name lib) (modes melange) (melange.runtime_deps name.txt) (preprocess (pps melange.ppx))) Finally, update lib/lib.ml to read from the recently added file: let dir = [%bs.raw \"__dirname\"] let file = \"name.txt\" let name = Node.Fs.readFileSync (dir ^ \"/\" ^ file) `ascii After these changes, once we build the project, we should still be able to run the application file with Node: $ dune build @app $ node _build/default/app/app.js Jane The same approach could be used to copy fonts, CSS or SVG files, or any other asset in your project. Note that Dune offers great flexibility to copy runtime assets using wildcards or globs, so one can simplify the configuration when there are a lot of runtime dependencies, for example: (melange.runtime_deps (glob_files styles/*.css) (glob_files images/*.png) (glob_files static/*.{pdf,txt})) See the documentation for glob dependencies to learn more about it. With runtime dependencies, we have reached the end of this Dune guide for Melange developers. For further details about how Dune works and its integration with Melange, check the Dune documentation , and the Melange opam template . Communicate with JavaScript TODO: Sections will be something like: - intro: explain attributes, extensions, and `bs.` backwards compatibility - `melange.ppx` preprocessor and extensions - data types - call javascript from melange: - intro to external (link to OCaml docs) - bindings with external (to functions, objects or other values) - global values - call melange from javascript Additions to OCaml TODO: pipe first Melange for X users TODO: For ReScript users, for OCaml users, for TypeScript/JavaScript users.","title":"Learn"},{"location":"learn/#learn","text":"","title":"Learn"},{"location":"learn/#new-to-ocaml","text":"As Melange is a fork of the OCaml compiler, this documentation is designed to include the differences between both. But for the parts that overlap between Melange and OCaml, we will always refer to the main OCaml documentation throughout these docs. If you are completely new to OCaml, you might want to get familiar first with the language, there are plenty of resources available , but we recommend the following tutorials from the official OCaml website: A First Hour With OCaml OCaml Exercises","title":"New to OCaml?"},{"location":"learn/#why-melange","text":"Melange is a fork of the OCaml compiler that produces JavaScript. OCaml offers an industrial-strength, state-of-the-art type system and provides type inference with very few type annotations, proving invaluable in managing large projects. JavaScript is one of the most pervasive platforms to deploy and run software. Thanks to years of efforts to improve the different VMs available, the JavaScript code running on browsers and other environments is heavily optimized and can support use cases for large products and tools. Melange helps developers and companies bring the advantages of the OCaml platform to users of the Web platform in a way that makes it easy for developers to integrate with both ecosystems.","title":"Why Melange"},{"location":"learn/#a-bit-of-history","text":"To better understand where Melange comes from, it might help to go through some of the related projects that have appeared over the last decade or so.","title":"A bit of history"},{"location":"learn/#js_of_ocaml","text":"Js_of_ocaml is another OCaml to JavaScript compiler that was made public in 2011. In the presentation paper published in 2013, it\u2019s explicitly mentioned that one of its design goals was to remain as compatible as possible with the OCaml compiler, without requiring a lot of maintenance work, as the OCaml community was not excessively large at the time. To achieve this goal, Js_of_ocaml picks the bytecode generated by OCaml batch compilation and generates JavaScript from it. OCaml bytecode has a very stable interface, so Js_of_ocaml can easily upgrade to new versions of the compiler. Due to this design decision, it can also remain compatible with most of the OCaml ecosystem, as long as the tools or libraries don\u2019t rely on C code. The downside of using bytecode is that it gets harder to communicate with existing JavaScript code. For example, a Js_of_ocaml string is not compiled as a JavaScript string, so some conversion is needed for this and other types. Another downside is that the resulting JavaScript is hard to read, as it is converted from a low-level representation like bytecode.","title":"Js_of_ocaml"},{"location":"learn/#bucklescript","text":"Then, in 2016, Bob Zhang suggests on a Js_of_ocaml repository issue the possibility to start converting to JavaScript from an earlier stage of the compilation process, instead of using bytecode. This proposal fundamentally diverges from Js_of_ocaml original design and goals, so he starts working on what will become BuckleScript. BuckleScript gets some inspiration from Js_of_ocaml, for example in the way that JavaScript objects are represented with Js.t . But it differs from Js_of_ocaml in many ways: it can generate more readable and lighter code. It also generates one .js file per module, which makes it easier to integrate with existing JavaScript codebases. BuckleScript puts a big emphasis on communicating with JavaScript code through a rich collection of attributes applied to external primitives.","title":"BuckleScript"},{"location":"learn/#reason","text":"Around the same year, a project called Reason appears at Facebook. Led by Jordan Walke, the idea is to create an alternate syntax for OCaml that is closer to C and JavaScript. Even if Reason has no take on which platform the code is deployed \u2014native applications binaries, or web applications using JavaScript as a target language\u2014, BuckleScript adds first class support for Reason from early on. At that point, it becomes evident that the combination of Reason with BuckleScript is a great match: BuckleScript provides tools and infrastructure to work with JavaScript ecosystem, while Reason allows developers to write their programs in a syntax they are familiar with. Over time, and with help of other Facebook employees and the community providing bindings to pervasive JavaScript libraries like React.js with reason-react , the combination of Reason and BuckleScript gains adoption.","title":"Reason"},{"location":"learn/#bucklescript-gets-rebranded","text":"However, at some point the goals of both BuckleScript and Reason projects become harder to reconcile. In August 2020, the BuckleScript team decides to rename to ReScript, stops adding support for the latest versions of the Reason parser, and replaces it with a new parser that changes the syntax. The reasons for the rebranding are explained in the official ReScript blog post . The rebranding is trying to ease onboarding and adoption of the ReScript language, giving the project more chances to compete with mainstream compiled-to-JavaScript languages like TypeScript. However, for many existing users of BuckleScript and Reason, it is the explicit confirmation of something that had been hinted implicitly before: ReScript goals are not compatible with providing a good integration with the OCaml ecosystem.","title":"BuckleScript gets rebranded"},{"location":"learn/#melange-back-to-ocaml","text":"This is where Melange comes in. A few weeks after the rebranding of BuckleScript to ReScript, Ant\u00f3nio Monteiro starts working on a fork of BuckleScript with a simple (not easy) goal: replace the Ninja build system , which BuckleScript had been using from its creation, with Dune , which is the most used build system for OCaml projects. This fork of BuckleScript is later named Melange. After finishing the switch from Ninja to Dune, several additional features are added to bring it closer to OCaml. Some examples are the upgrade of the OCaml compiler version used by Melange, or modelling the changes to the OCaml compiler that Melange uses as just a plain library, instead of a full fork of the whole compiler. In September 2022, Ahrefs decides to invest on Melange by funding a project to deepen the integration between Dune and Melange. This project achieves its completion in Spring 2023, with the migration of Ahrefs frontend codebase to Melange and the new public releases that support it: version 3.8 of Dune and 1.0 of Melange.","title":"Melange: back to OCaml"},{"location":"learn/#package-management","text":"Melange uses a dual approach to package management: For Melange libraries and bindings, use opam . For JavaScript packages required by Melange bindings, use npm (or any of its alternatives ). This dual approach has some obvious downsides, such as forcing Melange applications to have both an <app_name>.opam and a package.json file. However, it unlocks the advantages of both ecosystems. As we will see below, opam has been designed for the OCaml language, which makes the developer experience fundamentally different from npm in the way it handles and installs dependencies. In the following sections, we will go through the details of how to use opam to define the dependencies of our application, as well as how to publish packages in the public opam repository. However, this documentation is not exhaustive and only covers what we believe are the most important parts for Melange developers. If you want to learn more about opam, please refer to the opam manual and FAQ page .","title":"Package management"},{"location":"learn/#opam-for-melange-developers","text":"Before diving into specifics about using opam, there are the two relevant differences between opam and npm that are worth mentioning. 1. One version of each package At any given time, any opam switch can only at most a single version of a package. This is known as a flat dependency graph, and some package managers in other languages (like Bower ) follow a similar approach. A flat dependency graph means that, for example, it is impossible to have two versions of reason-react installed in the same project. This avoids some headaches when one inadvertently installs two versions of a dependency. Also, and specifically for Melange, it helps keep the resulting JavaScript bundle lean and reduce page load for browser-based applications. On the other hand, upgrading your project dependencies to more recent versions might become tricky. Due to the restriction where only one version of a package can be installed, there is a higher chance for conflicts between the constraints of the transitive dependencies. If opam cannot find a solution, these conflicts need to be solved manually. This generally involves updating the conflicting dependency to make it compatible with a newer version of Melange or a transient dependency. 2. A source-based package manager for a compiled language opam distributes just the source code of the packages and leaves the compilation step to a build phase that runs when consuming them, after they have been fetched. As the package manager for a compiled language like OCaml, opam has first-class support for this build step. Every package must tell opam how it should be built, and the way to do this is by using the build field in the package .opam file. This is different from how npm handles packages. Because npm has been designed for JavaScript (an interpreted language) having a build step makes no sense. Whenever any project or community tries to use npm to distribute software that includes code written in compiled languages, the burden to distribute pre-built binaries is imposed on library authors, like the node-sass example shows. As Melange relies heavily on OCaml packages for the compilation step (either PPXs, linters, instrumentation, or any other build-time package), using opam provides access to these tools without library authors having to care about creating and distributing pre-built versions of their packages. Let\u2019s go now through the most common actions with opam when working on Melange projects. The following guide is based on the amazing opam for npm/yarn users guide by Louis ( @khady ).","title":"opam for Melange developers"},{"location":"learn/#initial-configuration","text":"The first thing to do is to install opam. There is an official documentation page on installation. Most of the time, we can simply get it from your package manager. Otherwise, binaries are provided for every platform. There is a necessary first step before using opam: opam init -a Here is what the documentation of the opam init command says: The init command initialises a local \"opam root\" (by default, ~/.opam/ ) that holds opam\u2019s data and packages. This is a necessary step for normal operation of opam. The initial software repositories are fetched, and an initial 'switch' can also be installed, according to the configuration and options. These can be afterwards configured using opam switch and opam repository. Additionally, this command allows to customise some aspects of opam\u2019s shell integration, when run initially (avoiding the interactive dialog), but also at any later time. The interesting parts are: The opam root is at ~/.opam opam uses shell integration to make our life easier opam uses the concept of a switch A switch is the equivalent of the node_modules folder in npm\u2019s world. It contains all the packages that are installed. There are local switches and global switches, in the same way we can have a node_modules folder local to our project or install global dependencies using yarn global or npm install -g . Global switches can be handy sometimes, but to avoid confusion, the recommendation is to avoid them. The default settings can be changed if the -a option is omitted while calling opam init .","title":"Initial configuration"},{"location":"learn/#minimal-appopam-file","text":"The equivalent to package.json is an app.opam file, where app is the name of the package. It is possible to have multiple opam files in the same directory or project. There is no opam command to manipulate the opam file. A command similar to npm init or yarn add does not exist in opam, so the updates in .opam files have to be done by hand. A minimal .opam file looks like this: opam-version: \"2.0\" name: \"my-app\" authors: \"Louis\" homepage: \"https://github.com/khady/example\" maintainer: \"ex@ample.com\" dev-repo: \"git+ssh://git@github.com:khady/example.git\" bug-reports: \"https://github.com/khady/example/issues\" version: \"0.1\" build: [ [ \"dune\" \"subst\" ] {pinned} [ \"dune\" \"build\" \"-p\" name \"-j\" jobs ] ] depends: [ \"dune\" {build} ] build: tells opam that dune is needed only to build the project.","title":"Minimal app.opam file"},{"location":"learn/#installing-packages","text":"The first thing we need is a local switch in the current project. To verify if a switch exists already, we can look for a _opam directory at the root of the project or use the opam switch command to identify if a switch already exists in the project folder. If it does not exist, we can create it with: opam switch create . 4.14.1 --deps-only If it exists, we can install the dependencies of the project with: opam install . --deps-only","title":"Installing packages"},{"location":"learn/#add-new-packages","text":"To add a new package to the opam switch, we can do: opam install <package_name> But opam will not modify the app.opam file during the installation, this has to be done by hand. It is as simple as adding the name of the package in the depends field.","title":"Add new packages"},{"location":"learn/#linking-packages-for-development","text":"This can be achieved with opam pin . For example, to pin a package to a specific commit on GitHub: opam pin add reason-react.dev https://github.com/reasonml/reason-react.git#61bfbfaf8c971dec5152bce7e528d30552c70bc5 Branch names can also be used. opam pin add reason-react.dev https://github.com/reasonml/reason-react.git#feature A shortcut to get the latest version of a package is to use the --dev-repo flag, e.g. opam pin add reason-react.dev --dev-repo To remove the pinning for any package, use opam unpin <package_name> or opam pin remove <package_name> . For other options, the command is well described in the official documentation .","title":"Linking packages for development"},{"location":"learn/#upgrading-packages","text":"To upgrade the installed packages to the latest version, run: opam upgrade <package_name> opam upgrade is also able to upgrade all the packages of the local switch if no package name is given. There is one big difference compared to npm: opam stores a local copy of the opam repository, like apt-get does in Debian. So we often want to update this copy before requesting an upgrade: opam update && opam upgrade <package_name>","title":"Upgrading packages"},{"location":"learn/#dev-dependencies","text":"You can use the with-dev-setup field to define dependencies that are only required at development time. For example: depends: [ \"ocamlformat\" {with-dev-setup} ] This has to be combined with the --with-dev-setup flag when installing dependencies, e.g. opam install --deps-only --with-dev-setup .","title":"Dev dependencies"},{"location":"learn/#lock-files","text":"Lock files are also not common yet in the opam world, but they can be used as follows: Using opam lock to generate the lock file when needed (basically after each opam install or opam upgrade ). Adding --locked to all the opam install --deps-only and opam switch create . commands.","title":"Lock files"},{"location":"learn/#bindings-and-package-management","text":"When writing Melange libraries that bind to existing JavaScript packages, the users of the Melange library will have to make sure to install those JavaScript packages manually. This is similar to how OCaml bindings to system libraries work, see examples like ocaml-mariadb or ocurl . The advantage of this approach \u2014as opposed to vendoring the JavaScript packages inside the bindings\u2014 is that it gives users of the bindings complete flexibility over the way these JavaScript packages are downloaded and bundled.","title":"Bindings and package management"},{"location":"learn/#build-system","text":"Melange is deeply integrated with Dune , the most widely used build system for OCaml. This integration enables developers to create a single project with both OCaml native executables and frontend applications that are built with Melange, and even share code between both platforms in an easy manner. The way Dune and Melange work with each other is as follows: Dune orchestrates and plans the work needed to compile a project, copies files when needed, and prepares everything so that Melange takes OCaml source files and convert them into JavaScript code. Let\u2019s now dive into the Melange compilation model and go through a brief guide on how to work with Dune in Melange projects.","title":"Build system"},{"location":"learn/#compilation-model","text":"Melange compiles a single source file (either .ml or .re for Reason syntax) to a single JavaScript module. This simplifies debugging the produced JavaScript code and allows to import assets like CSS files and fonts in the same way as one would do in a JavaScript project. Even if Melange does not handle the bundling of JavaScript code for web applications, its compilation model allows integration with tools such as Webpack , or other alternatives . The Melange opam template can be used as reference, as it provides an example of how to integrate Melange with Webpack.","title":"Compilation model"},{"location":"learn/#dune-for-melange-developers","text":"Dune is an OCaml build system that Melange projects can use to specify libraries and applications. It\u2019s optimized for monorepos and makes project maintenance easier. This section provides an overview of Dune\u2019s features and explains how to use it to build Melange applications.","title":"Dune for Melange developers"},{"location":"learn/#features","text":"Dune is designed with OCaml in mind, which makes it an ideal tool for Melange developers. It provides several benefits, including: Easy specification of libraries and executables. Optimized for monorepos: no need for npm link or similar solutions. Easy project maintenance, as one can rearrange folders without updating the paths to libraries. Hygiene is maintained in Dune by never writing in source folders by default, unless explicitly configured to do so. All the compilation artifacts are placed in a separate _build folder. Dune provides a variety of additional features including cram tests , integration with Odoc , Melange, Js_of_ocaml , watch mode , Merlin/LSP integration for editor support, cross compilation , and generation of opam files .","title":"Features"},{"location":"learn/#creating-a-new-project","text":"To understand how to use Dune, let\u2019s create a small Melange application using it. First of all, create an opam switch, like shown in the package management section : opam switch create . 4.14.1 --deps-only Install Dune and Melange in the switch: opam install dune melange Create a file named dune-project . This file will tell Dune a few things about our project configuration: (lang dune 3.8) (using melange 0.1) The first line (lang dune 3.8) tells Dune which version of the \"Dune language\" (the language used in dune files) we want to use. Melange is only compatible with versions of the Dune language equal or greater than 3.8. The second line (using melange 0.1) tells Dune we want to use the Melange extension of the Dune language .","title":"Creating a new project"},{"location":"learn/#adding-a-library","text":"Next, create a folder lib , and a dune file inside. Put the following content inside the dune file: (library (name lib) (modes melange)) Create a file lib.ml in the same folder: let name = \"Jane\" The top level configuration entries \u2014like the library one that appears in the dune file\u2014 are referred to as stanzas , and the inner ones \u2014like name and modes \u2014 are referred to as fields of the stanza. All stanzas are well covered in the Dune documentation site, where we can find the reference for the library stanza . Dune is designed to minimize changes in configuration when the project folder structure changes, so one can move around the lib folder to another place inside the project, and all build commands will still keep working without any changes in Dune configuration. Very handy!","title":"Adding a library"},{"location":"learn/#entry-points-with-melangeemit","text":"Libraries are useful to encapsulate behavior and logical components of our application, but they won\u2019t produce any JavaScript artifacts on their own. To generate JavaScript code, we need to define an entry point of our application. In the root folder, create another dune file: (melange.emit (target app) (libraries lib)) And an app.ml file: let () = Js.log Lib.name The melange.emit stanza is the one that tells Dune to generate JavaScript files from a set of libraries and modules. In-depth documentation about this stanza can be found on the Dune docs . The file structure of the app should look something like this: project_name/ \u251c\u2500\u2500 _opam \u251c\u2500\u2500 lib \u2502 \u251c\u2500\u2500 dune \u2502 \u2514\u2500\u2500 lib.ml \u251c\u2500\u2500 dune-project \u251c\u2500\u2500 dune \u2514\u2500\u2500 main.ml","title":"Entry points with melange.emit"},{"location":"learn/#building-the-project","text":"We can build the project now, which will produce the JavaScript code from our sources using the Melange compiler: $ dune build @melange This command tells dune to build all the targets that have an alias melange attached to them. Aliases are build targets that don\u2019t produce any file and have configurable dependencies. By default, all the targets in a melange.emit stanza and the libraries it depends on are attached to the melange alias. We can define explicit aliases though, as we will see below. If everything went well, we should be able to run the resulting JavaScript with Node. As we mentioned while going through its features, Dune places all artifacts inside the _build folder to not pollute any source folders. So we will point Node to the script placed in that folder, to see the expected output: $ node _build/default/app/app.js Jane One thing to note is that we have to look for the app.js file inside an app folder, but we don\u2019t have any such folder in our sources. The reason why this folder is created is to support multiple melange.emit stanzas in the same folder. To support this scenario, Dune will use the target field defined in the melange.emit to place the artifacts generated from a melange.emit stanza in the following folder: _build/default/$path-to-directory-of-melange-emit-stanza/$target This allows to have two or more melange.emit stanzas in the same folder without conflicts or overrides between each other.","title":"Building the project"},{"location":"learn/#using-aliases","text":"The default melange alias is useful for prototyping or when working on small projects, but larger projects might define multiple entry points or melange.emit stanzas. In these cases, it is useful to have a way to build individual stanzas. To do so, one can define explicit aliases for each one of them by using the alias field. Let\u2019s define a custom alias app for our melange.emit stanza: (melange.emit (target app) (alias app) (libraries lib)) Now, when building with Dune, we can refer to this new alias: $ dune build @app Note that if we try to build again using the default melange alias, Dune will return an error, as there are no more targets attached to it. $ dune build @melange Error: Alias \"melange\" specified on the command line is empty. It is not defined in . or any of its descendants.","title":"Using aliases"},{"location":"learn/#handling-assets","text":"The last topic we will go through in this demo project is asset handling. Sometimes we want to use CSS files, fonts, or other assets in our Melange projects. Due to the way Dune works, our assets will have to be copied to the _build folder as well. To make this process as easy as possible, the Melange integration with Dune provides two ways to do this: For library stanzas, a field melange.runtime_deps For melange.emit stanzas, a field runtime_deps Both fields are documented in the Melange page of the Dune documentation site. For the sake of learning how to work with assets in a Melange project, let\u2019s say that we want to read the string in Lib.name from a text file. We will combine the field melange.runtime_deps with some bindings to Node that Melange provides. Check the next section, \"Communicate with JavaScript\" , it you want to learn more about how bindings work. So, let\u2019s add a new file name.txt inside lib folder, that just contains the name Jane . Then, adapt the lib/dune file. We will need to add the melange.runtime_deps field, as well as a preprocessing field that will allow to use the bs.raw extension, in order to get the value of the __dirname environment variable: (library (name lib) (modes melange) (melange.runtime_deps name.txt) (preprocess (pps melange.ppx))) Finally, update lib/lib.ml to read from the recently added file: let dir = [%bs.raw \"__dirname\"] let file = \"name.txt\" let name = Node.Fs.readFileSync (dir ^ \"/\" ^ file) `ascii After these changes, once we build the project, we should still be able to run the application file with Node: $ dune build @app $ node _build/default/app/app.js Jane The same approach could be used to copy fonts, CSS or SVG files, or any other asset in your project. Note that Dune offers great flexibility to copy runtime assets using wildcards or globs, so one can simplify the configuration when there are a lot of runtime dependencies, for example: (melange.runtime_deps (glob_files styles/*.css) (glob_files images/*.png) (glob_files static/*.{pdf,txt})) See the documentation for glob dependencies to learn more about it. With runtime dependencies, we have reached the end of this Dune guide for Melange developers. For further details about how Dune works and its integration with Melange, check the Dune documentation , and the Melange opam template .","title":"Handling assets"},{"location":"learn/#communicate-with-javascript","text":"TODO: Sections will be something like: - intro: explain attributes, extensions, and `bs.` backwards compatibility - `melange.ppx` preprocessor and extensions - data types - call javascript from melange: - intro to external (link to OCaml docs) - bindings with external (to functions, objects or other values) - global values - call melange from javascript","title":"Communicate with JavaScript"},{"location":"learn/#additions-to-ocaml","text":"TODO: pipe first","title":"Additions to OCaml"},{"location":"learn/#melange-for-x-users","text":"TODO: For ReScript users, for OCaml users, for TypeScript/JavaScript users.","title":"Melange for X users"},{"location":"try/","text":"Try TBD. In this page, we will show some playground, in the same spirit as https://reasonml.github.io/en/try .","title":"Try"},{"location":"try/#try","text":"TBD. In this page, we will show some playground, in the same spirit as https://reasonml.github.io/en/try .","title":"Try"}]}